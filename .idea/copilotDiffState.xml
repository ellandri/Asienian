<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.venv/Lib/site-packages/allauth/mfa/webauthn/internal/auth.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.venv/Lib/site-packages/allauth/mfa/webauthn/internal/auth.py" />
              <option name="originalContent" value="from typing import Any, Dict, List, Optional&#10;&#10;from django.contrib.auth import get_user_model&#10;&#10;import fido2.features&#10;from fido2.server import Fido2Server&#10;from fido2.utils import websafe_decode&#10;from fido2.webauthn import (&#10;    AttestedCredentialData,&#10;    AuthenticationResponse,&#10;    AuthenticatorData,&#10;    PublicKeyCredentialRpEntity,&#10;    PublicKeyCredentialUserEntity,&#10;    RegistrationResponse,&#10;    ResidentKeyRequirement,&#10;    UserVerificationRequirement,&#10;)&#10;&#10;from allauth.account.utils import url_str_to_user_pk&#10;from allauth.core import context&#10;from allauth.mfa import app_settings&#10;from allauth.mfa.adapter import get_adapter&#10;from allauth.mfa.models import Authenticator&#10;&#10;&#10;fido2.features.webauthn_json_mapping.enabled =&quot;pass&quot;&#10;&#10;&#10;STATE_SESSION_KEY = &quot;mfa.webauthn.state&quot;&#10;EXTENSIONS = {&quot;credProps&quot;: True}&#10;&#10;&#10;def build_user_payload(user) -&gt; PublicKeyCredentialUserEntity:&#10;    kwargs = get_adapter().get_public_key_credential_user_entity(user)&#10;    return PublicKeyCredentialUserEntity(**kwargs)&#10;&#10;&#10;def get_state() -&gt; Optional[Dict]:&#10;    return context.request.session.get(STATE_SESSION_KEY)&#10;&#10;&#10;def set_state(state: Dict) -&gt; None:&#10;    context.request.session[STATE_SESSION_KEY] = state&#10;&#10;&#10;def clear_state() -&gt; None:&#10;    context.request.session.pop(STATE_SESSION_KEY, None)&#10;&#10;&#10;def get_server() -&gt; Fido2Server:&#10;    rp_kwargs = get_adapter().get_public_key_credential_rp_entity()&#10;    rp = PublicKeyCredentialRpEntity(**rp_kwargs)&#10;    verify_origin = None&#10;    if app_settings.WEBAUTHN_ALLOW_INSECURE_ORIGIN:&#10;        verify_origin = lambda o: True  # noqa&#10;    server = Fido2Server(rp, verify_origin=verify_origin)&#10;    return server&#10;&#10;&#10;def parse_registration_response(response: Any) -&gt; RegistrationResponse:&#10;    try:&#10;        return RegistrationResponse.from_dict(response)&#10;    except TypeError:&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;&#10;&#10;def begin_registration(user, passwordless: bool) -&gt; Dict:&#10;    server = get_server()&#10;    credentials = get_credentials(user)&#10;    registration_data, state = server.register_begin(&#10;        user=build_user_payload(user),&#10;        credentials=credentials,&#10;        resident_key_requirement=(&#10;            ResidentKeyRequirement.REQUIRED&#10;            if passwordless&#10;            else ResidentKeyRequirement.DISCOURAGED&#10;        ),&#10;        user_verification=(&#10;            UserVerificationRequirement.REQUIRED&#10;            if passwordless&#10;            else UserVerificationRequirement.DISCOURAGED&#10;        ),&#10;        extensions=EXTENSIONS,&#10;    )&#10;    set_state(state)&#10;    return dict(registration_data)&#10;&#10;&#10;def complete_registration(credential: Dict) -&gt; AuthenticatorData:&#10;    server = get_server()&#10;    state = get_state()&#10;    if not state:&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;    try:&#10;        binding = server.register_complete(state, credential)&#10;    except ValueError:&#10;        # raise ValueError(&quot;Wrong challenge in response.&quot;)&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;    clear_state()&#10;    return binding&#10;&#10;&#10;def get_credentials(user) -&gt; List[AttestedCredentialData]:&#10;    credentials: List[AttestedCredentialData] = []&#10;    authenticators = Authenticator.objects.filter(&#10;        user=user, type=Authenticator.Type.WEBAUTHN&#10;    )&#10;    for authenticator in authenticators:&#10;        credential_data = authenticator.wrap().authenticator_data.credential_data&#10;        if credential_data:&#10;            credentials.append(authenticator.wrap().authenticator_data.credential_data)&#10;    return credentials&#10;&#10;&#10;def get_authenticator_by_credential_id(&#10;    user, credential_id: bytes&#10;) -&gt; Optional[Authenticator]:&#10;    authenticators = Authenticator.objects.filter(&#10;        user=user, type=Authenticator.Type.WEBAUTHN&#10;    )&#10;    for authenticator in authenticators:&#10;        if (&#10;            credential_id&#10;            == authenticator.wrap().authenticator_data.credential_data.credential_id&#10;        ):&#10;            return authenticator&#10;    return None&#10;&#10;&#10;def parse_authentication_response(response: Any) -&gt; AuthenticationResponse:&#10;    try:&#10;        return AuthenticationResponse.from_dict(response)&#10;    except (TypeError, ValueError):&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;&#10;&#10;def begin_authentication(user=None) -&gt; Dict:&#10;    server = get_server()&#10;    request_options, state = server.authenticate_begin(&#10;        credentials=get_credentials(user) if user else [],&#10;        user_verification=UserVerificationRequirement.PREFERRED,&#10;    )&#10;    set_state(state)&#10;    return dict(request_options)&#10;&#10;&#10;def extract_user_from_response(response: Dict):&#10;    try:&#10;        user_handle = response.get(&quot;response&quot;, {}).get(&quot;userHandle&quot;)&#10;        user_pk = url_str_to_user_pk(websafe_decode(user_handle).decode(&quot;utf8&quot;))&#10;    except (ValueError, TypeError, KeyError):&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;    user = get_user_model().objects.filter(pk=user_pk).first()&#10;    if not user:&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;    return user&#10;&#10;&#10;def complete_authentication(user, response: Dict) -&gt; Authenticator:&#10;    credentials = get_credentials(user)&#10;    server = get_server()&#10;    state = get_state()&#10;    if not state:&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;    try:&#10;        binding = server.authenticate_complete(state, credentials, response)&#10;    except ValueError as e:&#10;        # ValueError: Unknown credential ID.&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;) from e&#10;    clear_state()&#10;    authenticator = get_authenticator_by_credential_id(user, binding.credential_id)&#10;    if not authenticator:&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;    return authenticator&#10;&#10;&#10;class WebAuthn:&#10;    def __init__(self, instance):&#10;        self.instance = instance&#10;&#10;    @classmethod&#10;    def add(cls, user, name: str, credential: dict) -&gt; &quot;WebAuthn&quot;:&#10;        instance = Authenticator(&#10;            user=user,&#10;            type=Authenticator.Type.WEBAUTHN,&#10;            data={&#10;                &quot;name&quot;: name,&#10;                &quot;credential&quot;: credential,&#10;            },&#10;        )&#10;        instance.save()&#10;        return cls(instance)&#10;&#10;    @property&#10;    def name(self) -&gt; str:&#10;        return self.instance.data[&quot;name&quot;]&#10;&#10;    @name.setter&#10;    def name(self, name: str):&#10;        self.instance.data[&quot;name&quot;] = name&#10;&#10;    @property&#10;    def authenticator_data(self) -&gt; AuthenticatorData:&#10;        return parse_registration_response(&#10;            self.instance.data[&quot;credential&quot;]&#10;        ).response.attestation_object.auth_data&#10;&#10;    @property&#10;    def is_passwordless(self) -&gt; Optional[bool]:&#10;        return (&#10;            self.instance.data.get(&quot;credential&quot;, {})&#10;            .get(&quot;clientExtensionResults&quot;, {})&#10;            .get(&quot;credProps&quot;, {})&#10;            .get(&quot;rk&quot;)&#10;        )&#10;" />
              <option name="updatedContent" value="from typing import Any, Dict, List, Optional&#10;&#10;from django.contrib.auth import get_user_model&#10;&#10;from fido2.server import Fido2Server&#10;from fido2.utils import websafe_decode&#10;from fido2.webauthn import (&#10;    AttestedCredentialData,&#10;    AuthenticationResponse,&#10;    AuthenticatorData,&#10;    PublicKeyCredentialRpEntity,&#10;    PublicKeyCredentialUserEntity,&#10;    RegistrationResponse,&#10;    ResidentKeyRequirement,&#10;    UserVerificationRequirement,&#10;)&#10;&#10;from allauth.account.utils import url_str_to_user_pk&#10;from allauth.core import context&#10;from allauth.mfa import app_settings&#10;from allauth.mfa.adapter import get_adapter&#10;from allauth.mfa.models import Authenticator&#10;&#10;&#10;STATE_SESSION_KEY = &quot;mfa.webauthn.state&quot;&#10;EXTENSIONS = {&quot;credProps&quot;: True}&#10;&#10;&#10;def build_user_payload(user) -&gt; PublicKeyCredentialUserEntity:&#10;    kwargs = get_adapter().get_public_key_credential_user_entity(user)&#10;    return PublicKeyCredentialUserEntity(**kwargs)&#10;&#10;&#10;def get_state() -&gt; Optional[Dict]:&#10;    return context.request.session.get(STATE_SESSION_KEY)&#10;&#10;&#10;def set_state(state: Dict) -&gt; None:&#10;    context.request.session[STATE_SESSION_KEY] = state&#10;&#10;&#10;def clear_state() -&gt; None:&#10;    context.request.session.pop(STATE_SESSION_KEY, None)&#10;&#10;&#10;def get_server() -&gt; Fido2Server:&#10;    rp_kwargs = get_adapter().get_public_key_credential_rp_entity()&#10;    rp = PublicKeyCredentialRpEntity(**rp_kwargs)&#10;    verify_origin = None&#10;    if app_settings.WEBAUTHN_ALLOW_INSECURE_ORIGIN:&#10;        verify_origin = lambda o: True  # noqa&#10;    server = Fido2Server(rp, verify_origin=verify_origin)&#10;    return server&#10;&#10;&#10;def parse_registration_response(response: Any) -&gt; RegistrationResponse:&#10;    try:&#10;        return RegistrationResponse.from_dict(response)&#10;    except TypeError:&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;&#10;&#10;def begin_registration(user, passwordless: bool) -&gt; Dict:&#10;    server = get_server()&#10;    credentials = get_credentials(user)&#10;    registration_data, state = server.register_begin(&#10;        user=build_user_payload(user),&#10;        credentials=credentials,&#10;        resident_key_requirement=(&#10;            ResidentKeyRequirement.REQUIRED&#10;            if passwordless&#10;            else ResidentKeyRequirement.DISCOURAGED&#10;        ),&#10;        user_verification=(&#10;            UserVerificationRequirement.REQUIRED&#10;            if passwordless&#10;            else UserVerificationRequirement.DISCOURAGED&#10;        ),&#10;        extensions=EXTENSIONS,&#10;    )&#10;    set_state(state)&#10;    return dict(registration_data)&#10;&#10;&#10;def complete_registration(credential: Dict) -&gt; AuthenticatorData:&#10;    server = get_server()&#10;    state = get_state()&#10;    if not state:&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;    try:&#10;        binding = server.register_complete(state, credential)&#10;    except ValueError:&#10;        # raise ValueError(&quot;Wrong challenge in response.&quot;)&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;    clear_state()&#10;    return binding&#10;&#10;&#10;def get_credentials(user) -&gt; List[AttestedCredentialData]:&#10;    credentials: List[AttestedCredentialData] = []&#10;    authenticators = Authenticator.objects.filter(&#10;        user=user, type=Authenticator.Type.WEBAUTHN&#10;    )&#10;    for authenticator in authenticators:&#10;        credential_data = authenticator.wrap().authenticator_data.credential_data&#10;        if credential_data:&#10;            credentials.append(authenticator.wrap().authenticator_data.credential_data)&#10;    return credentials&#10;&#10;&#10;def get_authenticator_by_credential_id(&#10;    user, credential_id: bytes&#10;) -&gt; Optional[Authenticator]:&#10;    authenticators = Authenticator.objects.filter(&#10;        user=user, type=Authenticator.Type.WEBAUTHN&#10;    )&#10;    for authenticator in authenticators:&#10;        if (&#10;            credential_id&#10;            == authenticator.wrap().authenticator_data.credential_data.credential_id&#10;        ):&#10;            return authenticator&#10;    return None&#10;&#10;&#10;def parse_authentication_response(response: Any) -&gt; AuthenticationResponse:&#10;    try:&#10;        return AuthenticationResponse.from_dict(response)&#10;    except (TypeError, ValueError):&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;&#10;&#10;def begin_authentication(user=None) -&gt; Dict:&#10;    server = get_server()&#10;    request_options, state = server.authenticate_begin(&#10;        credentials=get_credentials(user) if user else [],&#10;        user_verification=UserVerificationRequirement.PREFERRED,&#10;    )&#10;    set_state(state)&#10;    return dict(request_options)&#10;&#10;&#10;def extract_user_from_response(response: Dict):&#10;    try:&#10;        user_handle = response.get(&quot;response&quot;, {}).get(&quot;userHandle&quot;)&#10;        user_pk = url_str_to_user_pk(websafe_decode(user_handle).decode(&quot;utf8&quot;))&#10;    except (ValueError, TypeError, KeyError):&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;    user = get_user_model().objects.filter(pk=user_pk).first()&#10;    if not user:&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;    return user&#10;&#10;&#10;def complete_authentication(user, response: Dict) -&gt; Authenticator:&#10;    credentials = get_credentials(user)&#10;    server = get_server()&#10;    state = get_state()&#10;    if not state:&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;    try:&#10;        binding = server.authenticate_complete(state, credentials, response)&#10;    except ValueError as e:&#10;        # ValueError: Unknown credential ID.&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;) from e&#10;    clear_state()&#10;    authenticator = get_authenticator_by_credential_id(user, binding.credential_id)&#10;    if not authenticator:&#10;        raise get_adapter().validation_error(&quot;incorrect_code&quot;)&#10;    return authenticator&#10;&#10;&#10;class WebAuthn:&#10;    def __init__(self, instance):&#10;        self.instance = instance&#10;&#10;    @classmethod&#10;    def add(cls, user, name: str, credential: dict) -&gt; &quot;WebAuthn&quot;:&#10;        instance = Authenticator(&#10;            user=user,&#10;            type=Authenticator.Type.WEBAUTHN,&#10;            data={&#10;                &quot;name&quot;: name,&#10;                &quot;credential&quot;: credential,&#10;            },&#10;        )&#10;        instance.save()&#10;        return cls(instance)&#10;&#10;    @property&#10;    def name(self) -&gt; str:&#10;        return self.instance.data[&quot;name&quot;]&#10;&#10;    @name.setter&#10;    def name(self, name: str):&#10;        self.instance.data[&quot;name&quot;] = name&#10;&#10;    @property&#10;    def authenticator_data(self) -&gt; AuthenticatorData:&#10;        return parse_registration_response(&#10;            self.instance.data[&quot;credential&quot;]&#10;        ).response.attestation_object.auth_data&#10;&#10;    @property&#10;    def is_passwordless(self) -&gt; Optional[bool]:&#10;        return (&#10;            self.instance.data.get(&quot;credential&quot;, {})&#10;            .get(&quot;clientExtensionResults&quot;, {})&#10;            .get(&quot;credProps&quot;, {})&#10;            .get(&quot;rk&quot;)&#10;        )" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>